---
layout: default
title: Algorithm Proofs
---

<div class="proofs-page">
    <div class="container">
        <header class="page-header">
            <h1>Algorithm Complexity Proofs</h1>
            <p class="subtitle">Mathematical proofs with LaTeX and MathJax rendering</p>
            <p class="author">Copyright (C) 2025, Shyamal Suhana Chandra</p>
            <div style="margin-top: 2rem; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <a href="{{ '/' | relative_url }}" class="btn">üè† Back to Home</a>
                <a href="{{ '/COMPLEXITY_PROOFS.md' | relative_url }}" class="btn">üìÑ View Markdown Summary</a>
                <a href="https://github.com/Sapana-Micro-Software/merry-go-round-splay-trees" class="btn" target="_blank">üîó GitHub Repository</a>
            </div>
        </header>

        <!-- Quick Navigation -->
        <div style="margin: 2rem 0; padding: 1.5rem; background: var(--bg-white); border-radius: var(--border-radius); box-shadow: var(--shadow);">
            <h3 style="text-align: center; color: var(--primary-color); margin-bottom: 1rem;">Quick Navigation</h3>
            <div style="display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
                <a href="#btree-proofs" class="btn" style="font-size: 0.9rem; padding: 0.5rem 1rem; color: white !important;">üå≥ B-Tree Proofs</a>
                <a href="#splay-proofs" class="btn" style="font-size: 0.9rem; padding: 0.5rem 1rem; color: white !important;">üîÑ Splay Tree Proofs</a>
                <a href="#circular-buffer-proofs" class="btn" style="font-size: 0.9rem; padding: 0.5rem 1rem; color: white !important;">üîÑ Circular Buffer Proofs</a>
                <a href="#rsync-proofs" class="btn" style="font-size: 0.9rem; padding: 0.5rem 1rem; color: white !important;">üì° Rsync Proofs</a>
                <a href="#thread-proofs" class="btn" style="font-size: 0.9rem; padding: 0.5rem 1rem; color: white !important;">üîí Thread-Safe Proofs</a>
            </div>
        </div>

        <div class="proofs-accordion" id="proofsAccordion">
            
            <!-- B-Tree Proofs -->
            <h2 id="btree-proofs" style="scroll-margin-top: 100px; color: var(--primary-color); margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary-color);">üå≥ B-Tree Proofs</h2>
            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">B-Tree Height Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: B-Tree Height</h3>
                        <p><strong>Statement:</strong> For a B-Tree of order $t$ (min degree) with $n$ keys, the height $h$ satisfies:</p>
                        <p>$$h \leq \log_t \frac{n+1}{2}$$</p>
                        
                        <h4>Proof:</h4>
                        <p>A B-Tree of height $h$ has at least:</p>
                        <ul>
                            <li>Root: 1 node with at least 1 key</li>
                            <li>Level 1: at least 2 nodes with at least $(t-1)$ keys each</li>
                            <li>Level 2: at least $2t$ nodes with at least $(t-1)$ keys each</li>
                            <li>Level $h$: at least $2t^{h-1}$ nodes with at least $(t-1)$ keys each</li>
                        </ul>
                        
                        <p>Total minimum keys:</p>
                        <div class="math-proof">
                            \begin{align}
                            n &\geq 1 + 2(t-1) + 2t(t-1) + \ldots + 2t^{h-1}(t-1) \\
                            n &\geq 1 + 2(t-1)(1 + t + t^2 + \ldots + t^{h-1}) \\
                            n &\geq 1 + 2(t-1)\frac{t^h - 1}{t - 1} \\
                            n &\geq 1 + 2(t^h - 1) \\
                            n &\geq 2t^h - 1 \\
                            t^h &\leq \frac{n+1}{2} \\
                            h &\leq \log_t \frac{n+1}{2}
                            \end{align}
                        </div>
                        
                        <p><strong>Corollary:</strong> Height is $O(\log_t n) = O(\log n)$ when $t$ is constant.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/btree-height.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/btree-height.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">B-Tree Search Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: B-Tree Search Complexity</h3>
                        <p><strong>Statement:</strong> Searching in a B-Tree with $n$ keys takes $O(\log n)$ time.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Search traverses from root to leaf: $O(\log_t n)$ levels</li>
                            <li>At each level, perform binary search on at most $(2t-1)$ keys: $O(t) = O(1)$ if $t$ is constant</li>
                            <li>Number of levels: $O(\log_t n) = O(\log n)$</li>
                            <li>Total time: $O(\log n) \times O(1) = O(\log n)$</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> B-Tree search has $O(\log n)$ time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/btree-search.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/btree-search.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">B-Tree Insert Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: B-Tree Insert Complexity</h3>
                        <p><strong>Statement:</strong> Inserting into a B-Tree with $n$ keys takes $O(\log n)$ time.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Find insertion point: $O(\log n)$ (same as search)</li>
                            <li>Insert into leaf: $O(1)$</li>
                            <li>If node splits:
                                <ul>
                                    <li>Split operation: $O(t) = O(1)$ if $t$ is constant</li>
                                    <li>Propagate split upward: at most $O(\log n)$ levels</li>
                                </ul>
                            </li>
                            <li>Total time: $O(\log n) + O(\log n) \times O(1) = O(\log n)$</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> B-Tree insert has $O(\log n)$ time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/btree-insert.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/btree-insert.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">B-Tree Delete Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: B-Tree Delete Complexity</h3>
                        <p><strong>Statement:</strong> Deleting from a B-Tree with $n$ keys takes $O(\log n)$ time.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Find node to delete: $O(\log n)$</li>
                            <li>If internal node, find predecessor/successor: $O(\log n)$</li>
                            <li>Delete from node: $O(1)$</li>
                            <li>Handle underflow:
                                <ul>
                                    <li>Borrow from sibling: $O(1)$</li>
                                    <li>Merge with sibling: $O(t) = O(1)$</li>
                                    <li>Propagate upward: at most $O(\log n)$ levels</li>
                                </ul>
                            </li>
                            <li>Total time: $O(\log n) + O(\log n) = O(\log n)$</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> B-Tree delete has $O(\log n)$ time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/btree-delete.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/btree-delete.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">B-Tree Space Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: B-Tree Space Complexity</h3>
                        <p><strong>Statement:</strong> A B-Tree with $n$ keys uses $O(n)$ space.</p>
                        
                        <h4>Proof:</h4>
                        <ul>
                            <li>Each key is stored exactly once: $n$ keys</li>
                            <li>Each node has at most $(2t-1)$ keys and $2t$ children pointers</li>
                            <li>Number of nodes: at most $\frac{n}{t-1} = O(n)$ when $t$ is constant</li>
                            <li>Total space:
                                <div class="math-proof">
                                    \begin{align}
                                    \text{Space} &= n \text{ keys} + O(n) \text{ pointers} \\
                                    &= O(n) + O(n) \\
                                    &= O(n)
                                    \end{align}
                                </div>
                            </li>
                        </ul>
                        
                        <p><strong>Conclusion:</strong> B-Tree space complexity is $O(n)$.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/btree-space.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/btree-space.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Splay Tree Proofs -->
            <h2 id="splay-proofs" style="scroll-margin-top: 100px; color: var(--primary-color); margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary-color);">üîÑ Splay Tree Proofs</h2>
            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Splay Tree Amortized Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Splay Tree Amortized Complexity</h3>
                        <p><strong>Statement:</strong> The amortized time per operation in a splay tree is $O(\log n)$.</p>
                        
                        <h4>Proof (Potential Method):</h4>
                        <p>Define potential function:</p>
                        <p>$$\Phi(T) = \sum_{v \in T} \log(\text{size}(v))$$</p>
                        <p>where $\text{size}(v)$ = number of nodes in subtree rooted at $v$.</p>
                        
                        <p>For operation with actual cost $c$, amortized cost:</p>
                        <p>$$\hat{c} = c + \Delta\Phi$$</p>
                        
                        <h5>Splay Operation Analysis:</h5>
                        <ul>
                            <li><strong>Zig step:</strong> amortized cost $\leq 3(r'(x) - r(x)) + 1$</li>
                            <li><strong>Zig-Zig step:</strong> amortized cost $\leq 3(r'(x) - r(x))$</li>
                            <li><strong>Zig-Zag step:</strong> amortized cost $\leq 3(r'(x) - r(x)) - 2$</li>
                        </ul>
                        
                        <p>where $r(x) = \log(\text{size}(x))$ and $r'(x)$ is rank after operation.</p>
                        
                        <p>Summing over all splay steps:</p>
                        <p>$$\text{Total amortized cost} \leq 3(r(\text{root}) - r(x)) + 1$$</p>
                        
                        <p>Since $r(\text{root}) = \log(n)$ and $r(x) \geq 0$:</p>
                        <p>$$\text{Amortized cost} \leq 3\log(n) + 1 = O(\log n)$$</p>
                        
                        <p><strong>Conclusion:</strong> Splay tree operations have $O(\log n)$ amortized complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/splay-amortized.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/splay-amortized.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">N-Way Splay Tree Search Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: N-Way Splay Tree Search Complexity</h3>
                        <p><strong>Statement:</strong> Searching in an N-way splay tree with $n$ nodes takes $O(\log n)$ amortized time.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Find node: $O(\log n)$ worst case (tree height)</li>
                            <li>Splay to root: $O(\log n)$ amortized (from Theorem 6)</li>
                            <li>Total: $O(\log n)$ amortized</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> N-way splay tree search has $O(\log n)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/splay-search.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/splay-search.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">N-Way Splay Tree Insert Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: N-Way Splay Tree Insert Complexity</h3>
                        <p><strong>Statement:</strong> Inserting into an N-way splay tree with $n$ nodes takes $O(\log n)$ amortized time.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Find insertion point: $O(\log n)$</li>
                            <li>Insert node: $O(1)$</li>
                            <li>Splay new node to root: $O(\log n)$ amortized</li>
                            <li>Adjust branching if needed: $O(1)$ amortized (infrequent)</li>
                            <li>Total: $O(\log n)$ amortized</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> N-way splay tree insert has $O(\log n)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/splay-insert.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/splay-insert.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">N-Way Splay Tree Delete Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: N-Way Splay Tree Delete Complexity</h3>
                        <p><strong>Statement:</strong> Deleting from an N-way splay tree with $n$ nodes takes $O(\log n)$ amortized time.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Splay node to root: $O(\log n)$ amortized</li>
                            <li>Delete root: $O(1)$</li>
                            <li>If needed, splay successor/predecessor: $O(\log n)$ amortized</li>
                            <li>Total: $O(\log n)$ amortized</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> N-way splay tree delete has $O(\log n)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/splay-delete.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/splay-delete.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Dynamic Branching Adjustment Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Dynamic Branching Adjustment Complexity</h3>
                        <p><strong>Statement:</strong> Adjusting branching factor in an N-way splay tree takes $O(1)$ amortized time per operation.</p>
                        
                        <h4>Proof:</h4>
                        <ol>
                            <li>Branching adjustment triggered when: $|\text{children}| > \text{maxChildren}$ or optimal branching changes</li>
                            <li>Split operation: $O(t)$ where $t$ is current branching factor</li>
                            <li>Since $t \leq \sqrt{n}$ (by design), split cost: $O(\sqrt{n})$</li>
                            <li>Split occurs at most once per $O(\sqrt{n})$ insertions</li>
                            <li>Amortized cost: $\frac{O(\sqrt{n})}{O(\sqrt{n})} = O(1)$</li>
                        </ol>
                        
                        <p><strong>Conclusion:</strong> Dynamic branching adjustment has $O(1)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/dynamic-branching.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/dynamic-branching.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">N-Way Splay Tree Space Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: N-Way Splay Tree Space Complexity</h3>
                        <p><strong>Statement:</strong> An N-way splay tree with $n$ nodes uses $O(n)$ space.</p>
                        
                        <h4>Proof:</h4>
                        <p>Each node stores:</p>
                        <ul>
                            <li>1 key</li>
                            <li>1 value</li>
                            <li>At most $\text{maxChildren}$ pointers to children</li>
                        </ul>
                        
                        <p>Number of nodes: $n$</p>
                        <p>Total pointers: at most $n \times \text{maxChildren}$</p>
                        
                        <h5>Worst Case Analysis:</h5>
                        <p>In worst case, $\text{maxChildren} = O(\sqrt{n})$ (by design constraint):</p>
                        <div class="math-proof">
                            \begin{align}
                            \text{Total space} &= n \text{ keys} + n \text{ values} + n \times O(\sqrt{n}) \text{ pointers} \\
                            &= O(n) + O(n) + O(n\sqrt{n}) \\
                            &= O(n\sqrt{n})
                            \end{align}
                        </div>
                        
                        <h5>Average Case Analysis:</h5>
                        <p>With dynamic branching adjustment, average branching factor is $O(1)$:</p>
                        <div class="math-proof">
                            \begin{align}
                            \text{Amortized space} &= n \text{ keys} + n \text{ values} + n \times O(1) \text{ pointers} \\
                            &= O(n) + O(n) + O(n) \\
                            &= O(n)
                            \end{align}
                        </div>
                        
                        <p><strong>Conclusion:</strong> N-way splay tree has $O(n)$ average space complexity with dynamic branching, and $O(n\sqrt{n})$ worst-case space complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/splay-space.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/splay-space.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Rsync Proofs -->
            <h2 id="rsync-proofs" style="scroll-margin-top: 100px; color: var(--primary-color); margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary-color);">üì° Rsync Proofs</h2>
            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Rsync Block Matching Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Block Matching Complexity</h3>
                        <p><strong>Statement:</strong> Finding matching blocks using rolling checksum in splay tree takes $O(m \log n)$ time where $m$ is number of blocks to match and $n$ is number of stored blocks.</p>
                        
                        <h4>Proof:</h4>
                        <p>For each of $m$ blocks:</p>
                        <ol>
                            <li>Compute rolling checksum: $O(1)$</li>
                            <li>Search in splay tree: $O(\log n)$ amortized</li>
                            <li>Verify strong hash: $O(1)$</li>
                        </ol>
                        
                        <p>Total: $m \times O(\log n) = O(m \log n)$</p>
                        
                        <h5>With Splay Optimization:</h5>
                        <p>Frequently matched blocks move to root, reducing average search time for common patterns.</p>
                        
                        <p><strong>Conclusion:</strong> Block matching has $O(m \log n)$ time complexity, with better average case for common patterns.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/rsync-block-matching.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/rsync-block-matching.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Rsync Tree Construction Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Rsync Tree Construction Complexity</h3>
                        <p><strong>Statement:</strong> Building splay tree from file with $b$ blocks takes $O(b \log b)$ time.</p>
                        
                        <h4>Proof:</h4>
                        <p>For each of $b$ blocks:</p>
                        <ol>
                            <li>Compute checksums: $O(1)$</li>
                            <li>Insert into tree: $O(\log i)$ where $i$ is current tree size</li>
                        </ol>
                        
                        <p>Sum: $\sum_{i=1}^{b} \log i = \log(b!) = b \log b$ (by Stirling's approximation)</p>
                        
                        <p><strong>Conclusion:</strong> Rsync tree construction has $O(b \log b)$ time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/rsync-construction.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/rsync-construction.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Circular Buffer Splay Tree Proofs -->
            <h2 id="circular-buffer-proofs" style="scroll-margin-top: 100px; color: var(--primary-color); margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary-color);">üîÑ Circular Buffer Splay Tree Proofs</h2>
            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Circular Buffer Splay Tree Search Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Circular Buffer Splay Tree Search Complexity</h3>
                        <p><strong>Statement:</strong> Searching in a Circular Buffer Splay Tree with $n$ nodes takes $O(\log n)$ amortized time.</p>
                        
                        <h4>Proof:</h4>
                        <p>The search operation consists of:</p>
                        <ol>
                            <li>Finding the node: $O(\log n)$ worst case (tree height)</li>
                            <li>Splay operation: $O(\log n)$ amortized (from standard splay tree analysis)</li>
                            <li>Buffer lookup: $O(1)$ (direct index access)</li>
                        </ol>
                        
                        <div class="math-proof">
                            \begin{align}
                            T(n) &= \text{Find node} + \text{Splay} + \text{Buffer operations} \\
                            &= O(\log n) + O(\log n) + O(1) \\
                            &= O(\log n) \text{ amortized}
                            \end{align}
                        </div>
                        
                        <p><strong>Conclusion:</strong> Circular Buffer Splay Tree search has $O(\log n)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/circular-buffer-splay-search.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/circular-buffer-splay-search.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Circular Buffer Splay Tree Insert Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Circular Buffer Splay Tree Insert Complexity</h3>
                        <p><strong>Statement:</strong> Inserting into a Circular Buffer Splay Tree with $n$ nodes takes $O(\log n)$ amortized time.</p>
                        
                        <h4>Proof:</h4>
                        <p>The insert operation consists of:</p>
                        <ol>
                            <li>Find insertion point: $O(\log n)$</li>
                            <li>Allocate node from buffer: $O(1)$</li>
                            <li>Insert node: $O(1)$</li>
                            <li>Splay new node to root: $O(\log n)$ amortized</li>
                            <li>Handle buffer overflow (if needed): $O(1)$ amortized</li>
                        </ol>
                        
                        <div class="math-proof">
                            \begin{align}
                            T(n) &= \text{Find} + \text{Allocate} + \text{Insert} + \text{Splay} + \text{Overflow} \\
                            &= O(\log n) + O(1) + O(1) + O(\log n) + O(1) \\
                            &= O(\log n) \text{ amortized}
                            \end{align}
                        </div>
                        
                        <p><strong>Conclusion:</strong> Circular Buffer Splay Tree insert has $O(\log n)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/circular-buffer-splay-insert.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/circular-buffer-splay-insert.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Circular Buffer Splay Tree Delete Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Circular Buffer Splay Tree Delete Complexity</h3>
                        <p><strong>Statement:</strong> Deleting from a Circular Buffer Splay Tree with $n$ nodes takes $O(\log n)$ amortized time.</p>
                        
                        <h4>Proof:</h4>
                        <p>The delete operation consists of:</p>
                        <ol>
                            <li>Find node to delete: $O(\log n)$</li>
                            <li>Splay node to root: $O(\log n)$ amortized</li>
                            <li>Delete node: $O(\log n)$ worst case</li>
                            <li>Deallocate from buffer: $O(1)$</li>
                        </ol>
                        
                        <div class="math-proof">
                            \begin{align}
                            T(n) &= \text{Find} + \text{Splay} + \text{Delete} + \text{Deallocate} \\
                            &= O(\log n) + O(\log n) + O(\log n) + O(1) \\
                            &= O(\log n) \text{ amortized}
                            \end{align}
                        </div>
                        
                        <p><strong>Conclusion:</strong> Circular Buffer Splay Tree delete has $O(\log n)$ amortized time complexity.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/circular-buffer-splay-delete.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/circular-buffer-splay-delete.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Circular Buffer Splay Tree Sort Complexity</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Circular Buffer Splay Tree Sort Complexity</h3>
                        <p><strong>Statement:</strong> Sorting a Circular Buffer Splay Tree with $n$ nodes takes $O(n)$ time for both ascending and descending order, regardless of comparison mode (lexicographic, numeric, or semantic).</p>
                        
                        <h4>Proof:</h4>
                        <p>The sort operation performs an in-order traversal:</p>
                        <ol>
                            <li>Visit all nodes: $O(n)$</li>
                            <li>Comparison per node: $O(1)$ for fixed-size keys, $O(k)$ for variable-size keys</li>
                            <li>Build result vector: $O(n)$</li>
                        </ol>
                        
                        <h5>For fixed-size keys or $O(1)$ comparators:</h5>
                        <div class="math-proof">
                            \begin{align}
                            T(n) &= \text{Traversal} + \text{Comparisons} + \text{Result building} \\
                            &= O(n) + O(n) + O(n) \\
                            &= O(n)
                            \end{align}
                        </div>
                        
                        <h5>For variable-size keys with lexicographic comparison:</h5>
                        <p>$T(n) = O(n \cdot k)$ where $k$ is the average key length.</p>
                        
                        <h5>Sort Order:</h5>
                        <ul>
                            <li><strong>Ascending:</strong> Traverse left $\rightarrow$ node $\rightarrow$ right: $O(n)$</li>
                            <li><strong>Descending:</strong> Traverse right $\rightarrow$ node $\rightarrow$ left: $O(n)$</li>
                        </ul>
                        
                        <h5>Comparison Modes:</h5>
                        <ul>
                            <li><strong>Lexicographic:</strong> $O(n \cdot k)$ where $k$ is key length</li>
                            <li><strong>Numeric:</strong> $O(n)$</li>
                            <li><strong>Semantic:</strong> Depends on comparator, typically $O(n)$ or $O(n \cdot k)$</li>
                        </ul>
                        
                        <p><strong>Conclusion:</strong> Circular Buffer Splay Tree sort has $O(n)$ time complexity for fixed-size keys, and $O(n \cdot k)$ for variable-size keys where $k$ is the key length.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/circular-buffer-splay-sort.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/circular-buffer-splay-sort.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Multithreading Proofs -->
            <h2 id="thread-proofs" style="scroll-margin-top: 100px; color: var(--primary-color); margin: 2rem 0 1rem 0; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary-color);">üîí Thread-Safe Proofs</h2>
            <div class="accordion-item">
                <button class="accordion-header" onclick="toggleAccordion(this)">
                    <span class="accordion-title">Thread-Safe Operation Overhead</span>
                    <span class="accordion-icon">‚ñº</span>
                </button>
                <div class="accordion-content">
                    <div class="proof-content">
                        <h3>Theorem: Thread-Safe Operation Overhead</h3>
                        <p><strong>Statement:</strong> Thread-safe operations add $O(1)$ overhead per operation in the uncontended case.</p>
                        
                        <h4>Proof:</h4>
                        <p>Thread-safe operations involve:</p>
                        <ul>
                            <li>Mutex lock/unlock: $O(1)$ in uncontended case</li>
                            <li>Atomic operations: $O(1)$</li>
                            <li>Thread pool enqueue: $O(1)$ amortized</li>
                        </ul>
                        
                        <h5>Uncontended Case:</h5>
                        <div class="math-proof">
                            \begin{align}
                            \text{Overhead} &= \text{lock} + \text{operation} + \text{unlock} \\
                            &= O(1) + O(1) + O(1) \\
                            &= O(1)
                            \end{align}
                        </div>
                        
                        <h5>Contended Case:</h5>
                        <p>When $k$ threads are waiting, lock acquisition is $O(k)$ worst case. However, with thread pool management, average overhead remains $O(1)$:</p>
                        <div class="math-proof">
                            \begin{align}
                            \text{Amortized overhead} &= \frac{\text{Total overhead}}{\text{Number of operations}} \\
                            &= \frac{O(n)}{n} \text{ (for $n$ operations)} \\
                            &= O(1)
                            \end{align}
                        </div>
                        
                        <p><strong>Conclusion:</strong> Thread-safe operations add $O(1)$ overhead per operation in the average case. For tree operations with $O(\log n)$ complexity, the $O(1)$ thread-safety overhead is dominated by the operation itself.</p>
                        
                        <div class="proof-downloads">
                            <a href="{{ '/proofs/thread-safe.tex' | relative_url }}" download class="btn-download">üìÑ Download LaTeX</a>
                            <a href="{{ '/proofs/thread-safe.pdf' | relative_url }}" class="btn-download" target="_blank">üìï View PDF</a>
                        </div>
                    </div>
                </div>
            </div>

        </div>
        
        <div class="proofs-footer">
            <p><strong>Copyright (C) 2025, Shyamal Suhana Chandra. All rights reserved.</strong></p>
            <p>All proofs are available in LaTeX (.tex) and PDF formats. PDFs are auto-generated via GitHub Actions.</p>
            <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <a href="{{ '/' | relative_url }}" class="btn">üè† Back to Home</a>
                <a href="{{ '/#complexity' | relative_url }}" class="btn">üìä View Complexity Table</a>
                <a href="{{ '/#visualizations' | relative_url }}" class="btn">üå≥ View Visualizations</a>
            </div>
        </div>
    </div>
</div>

<script>
function toggleAccordion(button) {
    const item = button.parentElement;
    const content = item.querySelector('.accordion-content');
    const icon = button.querySelector('.accordion-icon');
    const isActive = item.classList.contains('active');
    
    // Close all accordion items
    document.querySelectorAll('.accordion-item').forEach(item => {
        item.classList.remove('active');
        const content = item.querySelector('.accordion-content');
        if (content) {
            content.style.maxHeight = null;
        }
        const icon = item.querySelector('.accordion-icon');
        if (icon) {
            icon.textContent = '‚ñº';
        }
    });
    
    // Open clicked item if it wasn't active
    if (!isActive) {
        item.classList.add('active');
        content.style.maxHeight = content.scrollHeight + 'px';
        icon.textContent = '‚ñ≤';
        
        // Trigger MathJax re-render after opening
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([content]).catch(function (err) {
                console.error('MathJax rendering error:', err);
            });
        }
    }
}

// Initialize MathJax after page load
document.addEventListener('DOMContentLoaded', function() {
    // Ensure MathJax processes the page
    if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise().catch(function (err) {
            console.error('MathJax initial rendering error:', err);
        });
    }
    
    // Re-render MathJax when accordion opens
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                const target = mutation.target;
                if (target.classList.contains('active')) {
                    const content = target.querySelector('.accordion-content');
                    if (content && window.MathJax && window.MathJax.typesetPromise) {
                        window.MathJax.typesetPromise([content]).catch(function (err) {
                            console.error('MathJax rendering error:', err);
                        });
                    }
                }
            }
        });
    });
    
    document.querySelectorAll('.accordion-item').forEach(item => {
        observer.observe(item, { attributes: true });
    });
});
</script>
